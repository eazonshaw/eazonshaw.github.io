<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="This is the personal blog for Mr E.">



<title>算法与数据结构&amp;LeetCode | Mr E</title>



    <link rel="icon" href="/E.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Eazon&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Eazon&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div id="post-toc" class="post-toc">
            <span class="post-toc-title">catalogue</span>
            <div class="post-toc-content">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法与数据结构-amp-LeetCode"><span class="toc-text">算法与数据结构&amp;LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂度分析"><span class="toc-text">复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间复杂度"><span class="toc-text">空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组与链表"><span class="toc-text">数组与链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode"><span class="toc-text">LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array"><span class="toc-text">Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linked"><span class="toc-text">Linked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈和队列"><span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-1"><span class="toc-text">LeetCode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stack"><span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表、映射、集合"><span class="toc-text">哈希表、映射、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-2"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树、二叉搜索树"><span class="toc-text">二叉树、二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-3"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-4"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治、回溯"><span class="toc-text">分治、回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-5"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS、DFS"><span class="toc-text">BFS、DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-6"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法"><span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-7"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-8"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-9"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典树"><span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-10"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并查集"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-11"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的位运算公式"><span class="toc-text">常见的位运算公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-12"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#布隆过滤器"><span class="toc-text">布隆过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU缓存"><span class="toc-text">LRU缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-13"><span class="toc-text">LeetCode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode-14"><span class="toc-text">LeetCode</span></a></li></ol></li></ol></li></ol>
            </div>
        </div>
    
    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">算法与数据结构&amp;LeetCode</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Eazon Shaw</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 31, 2020&nbsp;&nbsp;14:59:32</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/数据结构与算法/">数据结构与算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <section class="post-content">
            <h1 id="算法与数据结构-amp-LeetCode"><a href="#算法与数据结构-amp-LeetCode" class="headerlink" title="算法与数据结构&amp;LeetCode"></a>算法与数据结构&amp;LeetCode</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>主要结合 LeetCode ，对算法与数据结构进行总结和分析。</p>
</blockquote>
<ul>
<li><p>核心：</p>
<ol>
<li>重在理解，避免死磕</li>
<li>重在练习，五遍刷题</li>
<li>机器思维，避免人肉</li>
</ol>
</li>
<li><p><a href="https://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c" target="_blank" rel="noopener">数据结构脑图</a></p>
</li>
<li><p><a href="https://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec" target="_blank" rel="noopener">算法脑图</a></p>
</li>
<li><p><a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener">小争哥的数据结构与算法之美专栏代码</a></p>
</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">如何理解算法时间复杂度表示法</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">主定理</a></li>
<li>O(1) 常数复杂度：Hash表，缓存</li>
<li>O(log n) 对数复杂度：二分查找，二叉搜索树</li>
<li>O(n) 线性复杂度：大多数遍历</li>
<li>O(n^2): 双重for循环</li>
<li>O(2^n)：递归</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul>
<li><strong>空间换时间，升维</strong>：在大多数情况下，会选择牺牲空间复杂度，来提高时间复杂度</li>
<li>一般在算法中，更多的是考虑是否为“原地算法”，即是否需要申请额外的空间。</li>
</ul>
<h2 id="数组与链表"><a href="#数组与链表" class="headerlink" title="数组与链表"></a>数组与链表</h2><blockquote>
<p><strong>非受限线性表</strong>：指的就是不受规则限制，区别于栈和队列。</p>
</blockquote>
<ul>
<li>数组和链表是所有数据结构的基础，基本上所有数据结构都可以基于数组和链表实现。</li>
<li>数组和链表之间重点掌握区别，数组的<strong>查找</strong>时间复杂度是O(1)，而链表的<strong>增加和删除</strong>时间复杂度为O(1)。</li>
<li>数组：注意防止越界</li>
<li>链表：单链表、双向链表、循环链表、静态链表（借助数组，伴随向后继节点的指针）</li>
</ul>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a> – 左右双指针夹逼</li>
<li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a> – 快慢指针</li>
<li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a> – 哈希表记录</li>
<li><strong><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></strong> – 排序，左右双指针夹逼/哈希表记录</li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a> – 快慢指针</li>
<li><strong><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></strong> – 额外空间+双指针，同于归并排序中的merge</li>
<li><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一</a></li>
</ul>
<h4 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h4><ul>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a> – 缓存</li>
<li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></li>
</ul>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p><strong>受限线性表</strong>：需要满足一定的规则，即先进后出或者先进先出等。</p>
</blockquote>
<ul>
<li>栈和队列的重点是掌握其在特殊场合下的应用。</li>
<li>栈：先进后出，FILO。应用：浏览器前进后退、括号匹配、表达式计算。</li>
<li>队列：先进先出，FIFO。</li>
<li>队列的拓展：双端队列（两边均可入队和出队），优先队列（根据优先级来出队）。</li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html" target="_blank" rel="noopener">Java PriorityQueue 源码</a></li>
</ul>
<h3 id="LeetCode-1"><a href="#LeetCode-1" class="headerlink" title="LeetCode"></a>LeetCode</h3><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul>
<li><strong><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></strong></li>
<li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></li>
<li><strong><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口</a></strong></li>
<li><a href="https://leetcode-cn.com/problems/trapping-rain-water/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">接雨水</a></li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul>
<li><a href="https://leetcode-cn.com/problems/design-circular-deque/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">设计循环双端队列</a></li>
</ul>
<h2 id="哈希表、映射、集合"><a href="#哈希表、映射、集合" class="headerlink" title="哈希表、映射、集合"></a>哈希表、映射、集合</h2><ul>
<li>哈希表：又称散列表。重点需要注意哈希冲突，设计好的哈希函数可以减少重复性，但不能完全避免哈希冲突。常用拉链表（散列表+链表）解决哈希冲突，如HashMap。</li>
<li>映射：Map。K/V键值对，key不重复</li>
<li>集合：Set。key不重复<h3 id="LeetCode-2"><a href="#LeetCode-2" class="headerlink" title="LeetCode"></a>LeetCode</h3></li>
<li><a href="https://leetcode-cn.com/problems/valid-anagram/description/" target="_blank" rel="noopener">有效的字母异位词</a></li>
<li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></li>
<li><a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener">两数之和</a></li>
</ul>
<h2 id="二叉树、二叉搜索树"><a href="#二叉树、二叉搜索树" class="headerlink" title="二叉树、二叉搜索树"></a>二叉树、二叉搜索树</h2><ul>
<li>顺序和链式结构都可以实现。</li>
<li>遍历方式：广度优先遍历（BFS）、深度优先遍历（DFS）；DFS分为前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）。重点掌握所有的模板。</li>
<li>分类：完全二叉树（除了叶子节点外，其余节点的度均为2的二叉树），满二叉树（最后一层全是叶子节点的完全二叉树），二叉搜索树等。</li>
<li>二叉搜索树的中序遍历即为有序遍历。</li>
<li><a href="https://visualgo.net/zh/bst" target="_blank" rel="noopener">自平衡二叉搜索树（AVL）的动图演示</a><h3 id="LeetCode-3"><a href="#LeetCode-3" class="headerlink" title="LeetCode"></a>LeetCode</h3></li>
<li><strong><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></strong></li>
<li><strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></strong></li>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/description/" target="_blank" rel="noopener">N叉树的前序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">N叉树的后序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">N叉树的层序遍历</a> – 广度优先搜索</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li><a href="https://shimo.im/docs/DjqqGCT3xqDYwPyY/read" target="_blank" rel="noopener">递归模板</a></li>
<li>核心：递归四部曲，终止条件、执行当前层逻辑、下坠、清理当前层的状态。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> param)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// terminator </span></span><br><span class="line">  <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123; </span><br><span class="line">    <span class="comment">// process result </span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// process current logic </span></span><br><span class="line">  process(level, param); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// drill down </span></span><br><span class="line">  recur( level: level + <span class="number">1</span>, newParam); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore current status </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="LeetCode-4"><a href="#LeetCode-4" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><strong><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯问题</a></strong> – 记忆化递归</li>
<li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></li>
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">翻转二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a>、<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></li>
<li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化和反序列化</a></li>
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序和中序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a></li>
<li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a>、<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></li>
</ul>
<h2 id="分治、回溯"><a href="#分治、回溯" class="headerlink" title="分治、回溯"></a>分治、回溯</h2><p><a href="https://shimo.im/docs/3xvghYh3JJPKwdvt/read" target="_blank" rel="noopener">分治代码模板</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_conquer</span><span class="params">(problem, param1, param2, ...)</span>:</span> </span><br><span class="line">  <span class="comment"># recursion terminator </span></span><br><span class="line">  <span class="keyword">if</span> problem <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">	print_result </span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># prepare data </span></span><br><span class="line">  data = prepare_data(problem) </span><br><span class="line">  subproblems = split_problem(problem, data) </span><br><span class="line"></span><br><span class="line">  <span class="comment"># conquer subproblems </span></span><br><span class="line">  subresult1 = self.divide_conquer(subproblems[<span class="number">0</span>], p1, ...) </span><br><span class="line">  subresult2 = self.divide_conquer(subproblems[<span class="number">1</span>], p1, ...) </span><br><span class="line">  subresult3 = self.divide_conquer(subproblems[<span class="number">2</span>], p1, ...) </span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">  <span class="comment"># process and generate the final result </span></span><br><span class="line">  result = process_result(subresult1, subresult2, subresult3, …)</span><br><span class="line">	</span><br><span class="line">  <span class="comment"># revert the current level states</span></span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-5"><a href="#LeetCode-5" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><strong><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></strong></li>
<li><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">求x的n次幂</a></li>
<li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></li>
<li><strong><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">多数元素</a></strong></li>
<li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></li>
<li><strong><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></strong></li>
</ul>
<h2 id="BFS、DFS"><a href="#BFS、DFS" class="headerlink" title="BFS、DFS"></a>BFS、DFS</h2><ul>
<li><p><a href="https://shimo.im/docs/P8TqKHGKt3ytkYYd/read" target="_blank" rel="noopener">BSF模板</a></p>
</li>
<li><p>核心：维护一个queue队列，建立一个访问记录visited集合，有时候还需要在节点处记录当前的层数level。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    visited = set()</span><br><span class="line">	queue = [] </span><br><span class="line">	queue.append([start]) </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> queue: </span><br><span class="line">		node = queue.pop() </span><br><span class="line">		visited.add(node)</span><br><span class="line"></span><br><span class="line">		process(node) </span><br><span class="line">		nodes = generate_related_nodes(node) </span><br><span class="line">		queue.push(nodes)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># other processing work </span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://shimo.im/docs/ddgwCccJQKxkrcTq/read" target="_blank" rel="noopener">DFS模板</a></p>
</li>
<li><p>核心：DFS在非递归写法时，是维护一个stack栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//递归写法</span><br><span class="line">visited = set() </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, visited)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> visited: <span class="comment"># terminator</span></span><br><span class="line">    	<span class="comment"># already visited </span></span><br><span class="line">    	<span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">	visited.add(node) </span><br><span class="line"></span><br><span class="line">	<span class="comment"># process current node here. </span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> next_node <span class="keyword">in</span> node.children(): </span><br><span class="line">		<span class="keyword">if</span> next_node <span class="keyword">not</span> <span class="keyword">in</span> visited: </span><br><span class="line">			dfs(next_node, visited)</span><br><span class="line">			</span><br><span class="line">//非递归写法</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, tree)</span>:</span> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">		<span class="keyword">return</span> [] </span><br><span class="line"></span><br><span class="line">	visited, stack = [], [tree.root]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> stack: </span><br><span class="line">		node = stack.pop() </span><br><span class="line">		visited.add(node)</span><br><span class="line"></span><br><span class="line">		process (node) </span><br><span class="line">		nodes = generate_related_nodes(node) </span><br><span class="line">		stack.push(nodes) </span><br><span class="line"></span><br><span class="line">	<span class="comment"># other processing work </span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="LeetCode-6"><a href="#LeetCode-6" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/#/description" target="_blank" rel="noopener">二叉树的层序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/#/description" target="_blank" rel="noopener">最小基因变化</a></li>
<li><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description" target="_blank" rel="noopener">在每个树行中找最大值</a></li>
<li><strong><a href="https://leetcode-cn.com/problems/word-ladder/description/" target="_blank" rel="noopener">单词接龙</a></strong> – DFS，双向DFS</li>
<li><a href="https://leetcode-cn.com/problems/word-ladder-ii/description/" target="_blank" rel="noopener">单词接龙II</a></li>
<li><strong><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿的数量</a></strong> – 下沉周围岛屿</li>
<li><a href="https://leetcode-cn.com/problems/minesweeper/description/" target="_blank" rel="noopener">扫雷游戏</a></li>
</ul>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul>
<li>贪心算法是<strong>弱化版的动态规划</strong>。很多时候都得<strong>先判断是否能用贪心算法</strong>解决，再使用贪心算法。如最经典的<code>找零</code>问题，在保证大的币种肯定是小的币种的倍数的情况下，可以利用贪心算法解决问题。<h3 id="LeetCode-7"><a href="#LeetCode-7" class="headerlink" title="LeetCode"></a>LeetCode</h3><a href="https://leetcode-cn.com/problems/lemonade-change/solution/" target="_blank" rel="noopener">柠檬水找零</a></li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li>特点：<strong>有序</strong>、<strong>有界</strong>、<strong>能够通过索引随机访问</strong>。</li>
<li><a href="https://shimo.im/docs/hjQqRQkGgwd9g36J/read" target="_blank" rel="noopener">二分查找模板</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, len(array) - <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> left &lt;= right: </span><br><span class="line">	  mid = (left + right) / <span class="number">2</span> </span><br><span class="line">	  <span class="keyword">if</span> array[mid] == target: </span><br><span class="line">		    <span class="comment"># find the target!! </span></span><br><span class="line">		    <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> result </span><br><span class="line">	  <span class="keyword">elif</span> array[mid] &lt; target: </span><br><span class="line">		    left = mid + <span class="number">1</span> </span><br><span class="line">	  <span class="keyword">else</span>: </span><br><span class="line">		    right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意，一般防止越界，第三行代码会改写为<code>mid = right + (left - right) &gt;&gt; 1</code></p>
<ul>
<li><a href="https://www.beyond3d.com/content/articles/8/" target="_blank" rel="noopener">Fast InvSqrt() 扩展阅读</a></li>
</ul>
</blockquote>
<h3 id="LeetCode-8"><a href="#LeetCode-8" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">x的平方根</a></li>
<li><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">有效的完全平方数</a></li>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></li>
<li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组中的最小值</a></li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>动态规划在大多数情况下和记忆化递归的时间复杂度相近，如经典的<a href="https://leetcode-cn.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">爬楼梯问题</a>，既可以使用斐波那契数列，<code>f(n) = f(n-1) + f(n-2)</code>，加上缓存cache的记忆化递归的方式求解，也可以使用动态规划，利用dp方程，<code>dp[i] = dp[i-1] + dp[i-2]</code>进行求解。</p>
</blockquote>
<ul>
<li>自底向上递推</li>
<li>核心：<strong>状态转移方程</strong>、<strong>最近重复子问题</strong>、<strong>最优子结构</strong></li>
</ul>
<h3 id="LeetCode-9"><a href="#LeetCode-9" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></li>
<li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/triangle/description/" target="_blank" rel="noopener">三角形最短路径和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/description/" target="_blank" rel="noopener">乘积最大子序列</a></li>
<li><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">硬币兑换</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家抢劫</a>、<a href="https://leetcode-cn.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">打家抢劫 II</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/#/description" target="_blank" rel="noopener">买买股票的最佳时机</a>、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">股票 II</a>、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">股票 III</a>、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">股票（含冷冻期）</a>、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">股票 IV</a>、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">股票（含手续费）</a> – <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">团灭股票问题方法</a></li>
</ul>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><ul>
<li>字典树，又称前缀树、Trie树。主要应用于搜索时前缀单词提示。</li>
<li>核心：理解和记忆Trie树的代码模板</li>
<li><a href="https://shimo.im/docs/Pk6vPY3HJ9hKkh33/read" target="_blank" rel="noopener">Trie树模板</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">		self.root = &#123;&#125; </span><br><span class="line">		self.end_of_word = <span class="string">"#"</span> </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span> </span><br><span class="line">		node = self.root </span><br><span class="line">		<span class="keyword">for</span> char <span class="keyword">in</span> word: </span><br><span class="line">			node = node.setdefault(char, &#123;&#125;) </span><br><span class="line">		node[self.end_of_word] = self.end_of_word </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span> </span><br><span class="line">		node = self.root </span><br><span class="line">		<span class="keyword">for</span> char <span class="keyword">in</span> word: </span><br><span class="line">			<span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node: </span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">			node = node[char] </span><br><span class="line">		<span class="keyword">return</span> self.end_of_word <span class="keyword">in</span> node </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix)</span>:</span> </span><br><span class="line">		node = self.root </span><br><span class="line">		<span class="keyword">for</span> char <span class="keyword">in</span> prefix: </span><br><span class="line">			<span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node: </span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">			node = node[char] </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="LeetCode-10"><a href="#LeetCode-10" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/" target="_blank" rel="noopener">实现Trie树</a></li>
<li><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">单词搜索 II</a></li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li>并查集，主要应用于解决站队问题，即朋友圈问题。</li>
<li>核心：熟悉并查集的基本操作，即初始化、查询、合并。</li>
<li><a href="https://shimo.im/docs/ydPCH33xDhK9YwWR/read" target="_blank" rel="noopener">并查集模板</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] parent; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		count = n; </span><br><span class="line">		parent = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">			parent[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">while</span> (p != parent[p]) &#123; </span><br><span class="line">			parent[p] = parent[parent[p]]; </span><br><span class="line">			p = parent[p]; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">int</span> rootP = find(p); </span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q); </span><br><span class="line">		<span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>; </span><br><span class="line">		parent[rootP] = rootQ; </span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="LeetCode-11"><a href="#LeetCode-11" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><strong><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">朋友圈问题</a></strong></li>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></li>
<li><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">被围绕的区域</a></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li>核心：记忆常见的位运算公式</li>
<li><a href="https://shimo.im/docs/rHTyt8hcpT6D9Tj8/read" target="_blank" rel="noopener">N皇后问题的位运算代码解法</a><h3 id="常见的位运算公式"><a href="#常见的位运算公式" class="headerlink" title="常见的位运算公式"></a>常见的位运算公式</h3></li>
</ul>
<ol>
<li>判断奇偶</li>
</ol>
<table>
<thead>
<tr>
<th>含义</th>
<th>常规</th>
<th>位运算</th>
</tr>
</thead>
<tbody><tr>
<td>判断偶数</td>
<td>x % 2 == 0</td>
<td>(x &amp; 1) == 0</td>
</tr>
<tr>
<td>判断基数</td>
<td>x % 2 == 1</td>
<td>(x &amp; 1) == 1</td>
</tr>
</tbody></table>
<ol start="2">
<li>除以2</li>
</ol>
<table>
<thead>
<tr>
<th>常规</th>
<th>位运算</th>
</tr>
</thead>
<tbody><tr>
<td>x / 2</td>
<td>x &gt;&gt; 1</td>
</tr>
<tr>
<td>int mid = (left + right)/2</td>
<td>int mid = (left + right) &gt;&gt; 1</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>清零最低位的1（即：从第0位开始往前，第1个1置为0）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x &amp; (x - 1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取最低位的1（即：从第0位开始往前，获取第1个1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp; (-x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>取0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp; (~x)</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-12"><a href="#LeetCode-12" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">位1的个数</a></li>
<li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">颠倒二进制位</a></li>
<li><a href="https://leetcode-cn.com/problems/n-queens/description/" target="_blank" rel="noopener">N皇后</a></li>
<li><a href="https://leetcode-cn.com/problems/n-queens-ii/description/" target="_blank" rel="noopener">N皇后 II</a></li>
<li><a href="https://leetcode-cn.com/problems/counting-bits/description/" target="_blank" rel="noopener">比特位计数</a></li>
</ul>
</li>
</ol>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><ul>
<li>核心：<strong>判断不存在百分之百正确，判断存在不一定正确</strong></li>
<li>应用：布隆过滤器一般用于做最外层的过滤缓存</li>
<li>实现：利用Hash函数将待判断Key对应到多个位上（由于可能存在Key值对应的位重叠，所以判断存在不一定正确）</li>
<li><a href="https://www.cnblogs.com/cpselvis/p/6265825.html" target="_blank" rel="noopener">布隆过滤器的原理和实现</a></li>
<li><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74721877" target="_blank" rel="noopener">使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</a></li>
<li>代码实现：</li>
</ul>
<ol>
<li>python：<a href="https://shimo.im/docs/xKwrcwrDxRv3QpKG/read" target="_blank" rel="noopener">代码示例</a>、<a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">实现示例</a>、<a href="https://github.com/jhgg/pybloof" target="_blank" rel="noopener">高性能布隆过滤器</a></li>
<li>java：<a href="https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java" target="_blank" rel="noopener">代码示例 I</a>、<a href="https://github.com/Baqend/Orestes-Bloomfilter" target="_blank" rel="noopener">代码示例 II</a></li>
</ol>
<h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><ul>
<li>核心：<strong>散列表+双向链表</strong>、get和set都是O(1)的时间复杂度</li>
<li>关键词：<strong>最近最少使用</strong></li>
<li><a href="https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/" target="_blank" rel="noopener">用简单的话理解开发容灾</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" target="_blank" rel="noopener">替换算法总揽</a></li>
<li><a href="https://shimo.im/docs/tTxRkGwJpXG6WkGY/read" target="_blank" rel="noopener">LRU Cache python 代码示例</a></li>
<li>基于JAVA的LinkedHashMap（本质即散列表+链表）实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="LeetCode-13"><a href="#LeetCode-13" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/lru-cache/#/" target="_blank" rel="noopener">LRU缓存机制</a></li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>核心：<strong>熟悉含义，了解代码</strong></li>
<li>（平均）时间复杂度：</li>
</ul>
<ol>
<li>O(n^2)：冒泡排序、插入排序、选择排序</li>
<li>O(nlogn)：快速排序、归并排序</li>
<li>O(n)：桶排序、基数排序、计数排序<br><img src="https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" alt></li>
</ol>
<ul>
<li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大排序算法动图演示</a></li>
<li><a href="https://shimo.im/docs/98KjvGwwGpTpYGKy/read" target="_blank" rel="noopener">快速排序代码示例</a></li>
<li><a href="https://shimo.im/docs/YqgG6vtdKwkXJkWx/read" target="_blank" rel="noopener">归并排序代码示例</a></li>
<li><a href="https://shimo.im/docs/6kRVHRphpgjHgCtx/read" target="_blank" rel="noopener">堆排序代码示例</a></li>
</ul>
<h3 id="LeetCode-14"><a href="#LeetCode-14" class="headerlink" title="LeetCode"></a>LeetCode</h3><ul>
<li><a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">数组的相对排序</a></li>
<li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位</a></li>
<li><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">翻转对</a></li>
</ul>

        </section>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Eazon Shaw</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://eazon.xyz/2020/03/31/算法与数据结构/">http://eazon.xyz/2020/03/31/算法与数据结构/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Solgan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/算法/"># 算法</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/03/28/【JAVA业务需要注意的点】数据库索引问题/">【JAVA业务需要注意的点】数据库索引问题</a>
            
        </section>


    </article>
</div>
        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Eazon Shaw | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Sirice19/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
    </div>
</body>
</html>